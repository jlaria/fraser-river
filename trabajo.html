<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Predicción de catástrofes en Fraser River</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-1.1/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}

.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>
<script>
$(document).ready(function () {
  window.initializeCodeFolding("hide" === "show");
});
</script>




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Trabajo Final Estadística Bayesiana</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Inicio</a>
</li>
<li>
  <a href="trabajo.html">Informe</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Predicción de catástrofes en Fraser River</h1>

</div>


<div id="motivacion" class="section level2">
<h2>Motivación</h2>
<p>Se tiene información sobre el nivel medio mensual del río Fraser, en Canadá, desde Marzo de 1913 hasta Diciembre de 1990. Se pide estimar la probabilidad de que el río desborde superando los 10000 <span class="math inline">\(m^3/s\)</span>.</p>
</div>
<div id="datos" class="section level2">
<h2>Datos</h2>
<p>Los datos utilizados están disponibles en <a href="http://lib.stat.cmu.edu/datasets/fraser-river" class="uri">http://lib.stat.cmu.edu/datasets/fraser-river</a>. Se tienen <span class="math inline">\(946\)</span> observaciones de una variable (nivel medio mensual).</p>
<pre class="r"><code>river &lt;- read.table(&#39;fraser-river.txt&#39;); head(river)</code></pre>
<pre><code>##     V1
## 1  485
## 2 1150
## 3 4990
## 4 6130
## 5 4780
## 6 3960</code></pre>
</div>
<div id="modelo" class="section level2">
<h2>Modelo</h2>
<p>En este trabajo se considerará que las observaciones provienen de un modelo PAR (Periodic AutoRegresive), como sugiere <span class="citation">McLeod (1994)</span>.</p>
<p>La periodicidad de la serie puede observarse en la siguiente figura. Note que, naturalmente, el período de la serie es 12.</p>
<pre class="r"><code>ts.plot(river[1:100,], ylab=&#39;Nivel del río&#39;, xlab=&#39;Meses&#39;)</code></pre>
<p><img src="trabajo_files/figure-html/unnamed-chunk-2-1.png" width="480" /></p>
<p>Es posible considerar también una tendencia a lo largo de los años, pero en este caso no parece haber tal relación.</p>
<p>En este caso, un gráfico ACF es muy informativo, pues permite estimar el orden de la dependencia entre los meses consecutivos.</p>
<pre class="r"><code>acf(river)</code></pre>
<p><img src="trabajo_files/figure-html/unnamed-chunk-3-1.png" width="480" /></p>
<p>Todas las correlaciones entre meses son significativas. Aunque pudiese tratarse el problema analizando todas estas dependencias para cada mes, el modelo resultante sería demasiado complicado y posiblemente asociado a pobres estimaciones de los parámetros. Es lógico suponer que dada una fecha, el nivel del río ese mes dependerá de dos componentes: el nivel del río observado en el mes anterior y el nivel medio histórico del río ese mes. Se formulará este problema como sigue,</p>
<p><span class="math display">\[ y_t = \phi_{0s} + \phi_{1s} y_{t-1} + \varphi_{s}\epsilon_t, \quad \epsilon_t \sim N(0,1), \]</span> donde <span class="math inline">\(s=1,2 \ldots 12\)</span>, <span class="math inline">\(t=1,2 \ldots n\)</span>. Los parámetros <span class="math inline">\(\phi_{0s}\)</span> controlan el nivel medio del río en cada mes según el hitórico, mientras que <span class="math inline">\(\phi_{1s}\)</span> determina la tendencia para cada año. Es lógico suponer que la varianza <span class="math inline">\(\varphi_s\)</span> varía según el mes. Por ejemplo, el mes de Marzo suele ser poco lluvioso siempre, mientras que otros meses como Mayo pueden ser lluviosos o no.</p>
<p>El modelo jerárquico queda,</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(Y_{t} \big|\{ \phi_{0s}, \phi_{1s}, \varphi_s, Y_{t-1} \} \sim Normal(\phi_{0s} + \phi_{1s} Y_{t-1}, \varphi_s)\)</span>,</li>
<li><span class="math inline">\(\phi_{0s}\sim Normal(\mu, \sigma^2)\)</span>,</li>
<li><span class="math inline">\(\phi_{1s}\sim Normal(\mu, \sigma^2)\)</span>,</li>
<li><span class="math inline">\(\varphi_{s}\sim InvGamma(\alpha, \beta)\)</span>.</li>
</ol>
</div>
<div id="implementacion" class="section level2">
<h2>Implementación</h2>
<p>Para estimar los parámetros del modelo se ha utilizado la librería <code>rstan</code> de <code>R</code>.</p>
<p>Se ha aplicado previamente a los datos una transformación logarítmica. Esto se sugiere en <span class="citation">McLeod (1994)</span>, cuando se tienen datos reales, con el fin de estabilizar la varianza.</p>
<pre class="r"><code># Centramos los datos para que las observaciones comiencen en el mes de enero.
flow &lt;- log(c(as(river[-(1:10),],&#39;double&#39;),as(river[(1:10),],&#39;double&#39;)))

library(refund)
library(refund.shiny)
library(tidyverse)</code></pre>
<pre><code>## Loading tidyverse: ggplot2
## Loading tidyverse: tibble
## Loading tidyverse: tidyr
## Loading tidyverse: readr
## Loading tidyverse: purrr
## Loading tidyverse: dplyr</code></pre>
<pre><code>## Conflicts with tidy packages ----------------------------------------------</code></pre>
<pre><code>## filter(): dplyr, stats
## lag():    dplyr, stats</code></pre>
<pre class="r"><code>river.flow &lt;- matrix(flow[1:936], ncol= 12, byrow = T)
as_refundObj(river.flow) %&gt;%
  ggplot(aes(x = index, y = value, group = id)) + geom_path(alpha = .2)</code></pre>
<p><img src="trabajo_files/figure-html/unnamed-chunk-4-1.png" width="480" /></p>
<p>Para estimar la probabilidad de que el río desborde simularemos muchas observaciones de la serie. La probabilidad de que el río desborde será estimada a través de la proporción de veces que el nivel medio ha sobrepasado el límite en las series simuladas.</p>
<p>El código del programa en Stan para el modelo considerado sería como sigue.</p>
<pre class="r"><code>programa&lt;-&#39;
data{
  // Datos externos
  int&lt;lower=1&gt; N; // Tamaño de la serie
  int&lt;lower=1&gt; N_new; // Tamaño de la serie a predecir
  real&lt;lower=0&gt; y[N]; // Serie observada
  real jan_new; // Valor (fijo) del mes de Enero de la serie a predecir  
  real mu; 
  real&lt;lower=0&gt; sigma; 
  real&lt;lower=0&gt; alpha;
  real&lt;lower=0&gt; beta;
}
parameters{
    // Parámetros a estimar
    real phi0[12]; // Nivel histórico medio mensual
    real phi1[12]; // Pendiente cada mes y el siguiente
    real&lt;lower=0&gt; varphi2[12]; // Varianza del nivel medio por mes
}
transformed parameters{
  // Transformaciones para notación
  real&lt;lower=0&gt; varphi[12];
  for(s in 1:12){
    varphi[s]=sqrt(varphi2[s]);
  }
}
model{
  // Formulación del modelo
  int season;
  season = 2;
  for(i in 2:N){
    y[i] ~ normal( phi0[season]+phi1[season]*y[i-1], varphi[season] );
    season=season+1;
    if(season&gt;12){
      season=1;
    }
  }
  
  for (s in 1:12){
    phi0[s] ~ normal( mu, sigma ); // densidad a-priori normal
    phi1[s] ~ normal( mu, sigma );
    varphi2[s] ~ inv_gamma( alpha, beta ); // densidad a-priori inversa gamma
  }
}
generated quantities{
  // Valores simulados para estimar

  vector[N_new] y_new;
  int season;
  season = 2;

  y_new[1]=jan_new;

  for(i in 2:N_new){
    y_new[i] = normal_rng( phi0[season]+phi1[season]*y_new[i-1], varphi[season] );
    season=season+1;
    if(season&gt;12){
      season=1;
    }
  }
}
&#39;</code></pre>
<p>Compilamos el código de Stan.</p>
<pre class="r"><code>library(rstan)</code></pre>
<pre><code>## Loading required package: StanHeaders</code></pre>
<pre><code>## rstan (Version 2.14.1, packaged: 2016-12-28 14:55:41 UTC, GitRev: 5fa1e80eb817)</code></pre>
<pre><code>## For execution on a local, multicore CPU with excess RAM we recommend calling
## rstan_options(auto_write = TRUE)
## options(mc.cores = parallel::detectCores())</code></pre>
<pre><code>## 
## Attaching package: &#39;rstan&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:tidyr&#39;:
## 
##     extract</code></pre>
<pre class="r"><code>rstan_options(auto_write=T)
options(mc.cores=parallel::detectCores()-1)

programa_c&lt;-stan_model(model_code=programa)</code></pre>
<p>Preparamos los parámetros del modelo.</p>
<pre class="r"><code>N &lt;- length(flow) 
N_new &lt;- 144
jan_new &lt;- flow[1]
alpha &lt;- 0.5
beta &lt;- 0.5
mu &lt;- 3
sigma &lt;- 100
datos &lt;- list(y=flow, N=N, N_new=N_new, jan_new=jan_new, mu=mu, sigma=sigma, beta=beta, alpha=alpha)</code></pre>
<p>Note que se ha considerado una <em>a priori</em> poco informativa para la media mensual del nivel del río y la pendiente entre meses consecutivos, pues se tiene una muestra de datos suficientemente grande para estimar estos parámetros. Para la varianza del nivel medio mensual también se ha considerado una <em>a-priori</em> poco informativa, equivalente a una observación con varianza <span class="math inline">\(1\)</span>.</p>
<p>Simulamos del modelo de Stan.</p>
<pre class="r"><code>result &lt;- sampling(programa_c, data=datos, iter=1500, chains=1)</code></pre>
<pre><code>## 
## SAMPLING FOR MODEL &#39;0b66fe4f96586d41e76dcf5c9d9f2fee&#39; NOW (CHAIN 1).
## 
## Chain 1, Iteration:    1 / 1500 [  0%]  (Warmup)
## Chain 1, Iteration:  150 / 1500 [ 10%]  (Warmup)
## Chain 1, Iteration:  300 / 1500 [ 20%]  (Warmup)
## Chain 1, Iteration:  450 / 1500 [ 30%]  (Warmup)
## Chain 1, Iteration:  600 / 1500 [ 40%]  (Warmup)
## Chain 1, Iteration:  750 / 1500 [ 50%]  (Warmup)
## Chain 1, Iteration:  751 / 1500 [ 50%]  (Sampling)
## Chain 1, Iteration:  900 / 1500 [ 60%]  (Sampling)
## Chain 1, Iteration: 1050 / 1500 [ 70%]  (Sampling)
## Chain 1, Iteration: 1200 / 1500 [ 80%]  (Sampling)
## Chain 1, Iteration: 1350 / 1500 [ 90%]  (Sampling)
## Chain 1, Iteration: 1500 / 1500 [100%]  (Sampling)
##  Elapsed Time: 54.067 seconds (Warm-up)
##                45.9757 seconds (Sampling)
##                100.043 seconds (Total)</code></pre>
<p>Extraemos los resultados del modelo.</p>
<pre class="r"><code>result.sim &lt;- rstan::extract(result)
# Número medio de desbordamientos en la simulación.
mean(result.sim$y_new[,]&gt;log(10000))</code></pre>
<pre><code>## [1] 0.005555556</code></pre>
<p>Podemos observar las trayectorias simuladas.</p>
<pre class="r"><code>river.flow &lt;- matrix(t(result.sim$y_new[sample(1:500, 30),13:144]), ncol= 12, byrow = T)
as_refundObj(river.flow) %&gt;%
  ggplot(aes(x = index, y = value, group = id)) + geom_path(alpha = .1)</code></pre>
<p><img src="trabajo_files/figure-html/unnamed-chunk-10-1.png" width="480" /></p>
<p>Podemos visualizar la función de densidad marginal del nivel medio del río en cierto mes.</p>
<pre class="r"><code>dat &lt;- data.frame(river.flow) 
names(dat)&lt;-month.name

plot.datos&lt;-data.frame(Month=rep(c(&#39;Abril&#39;,&#39;Mayo&#39;), each=nrow(dat)), River=c(dat$April, dat$May))

ggplot(plot.datos, aes(x=River, fill=Month, colour=Month))+geom_density(alpha=0.3)</code></pre>
<p><img src="trabajo_files/figure-html/unnamed-chunk-11-1.png" width="480" /></p>
<p>Como se observa en la figura anterior, el modelo estimado capta la diferencia en el régimen de lluvias entre los meses de Abril y Mayo.</p>
</div>
<div id="resultados" class="section level2 unnumbered">
<h2>Resultados</h2>
<div id="refs" class="references">
<div id="ref-mcleod1994diagnostic">
<p>McLeod, A Ian. 1994. “Diagnostic Checking of Periodic Autoregression Models with Application.” <em>Journal of Time Series Analysis</em> 15 (2). Wiley Online Library: 221–33.</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
